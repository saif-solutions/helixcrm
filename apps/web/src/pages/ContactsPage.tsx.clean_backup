/**
 * Contacts List Page - CLEAN VERSION
 * 
 * HELIX CRM - Multi-tenant Contacts Management
 */
import React, { useState, useEffect, ChangeEvent, useCallback } from 'react';
import { useAuth } from '../hooks/useAuth';
import { useToast } from '../components/feedback/ToastProvider';
import { Card } from '../components/ui/Card';
import { Button } from '../components/ui/Button';
import { Input } from '../components/ui/Input';
import { Table, TableHeader, TableBody, TableRow, TableHead, TableCell } from '../components/ui/Table';
import { Modal } from '../components/ui/Modal';
import { ConfirmationModal } from '../components/ui/ConfirmationModal';
import { ContactForm } from '../components/contacts/ContactForm';
import { LoadingSpinner } from '../components/feedback/LoadingSpinner';
import { EmptyState } from '../components/feedback/EmptyState';
import { Plus, Search, Loader2 } from 'lucide-react';
import { contactsService } from '../services/contacts.service';

interface Contact {
  id: string;
  firstName: string;
  lastName: string;
  email: string;
  phone?: string;
  organizationId: string;
  createdAt: string;
  updatedAt: string;
}

type FormMode = 'create' | 'edit';

export const ContactsPage: React.FC = () => {
  const { user, token } = useAuth();
  const { success, error: showError, info } = useToast();
  const [contacts, setContacts] = useState<Contact[]>([]);
  const [filteredContacts, setFilteredContacts] = useState<Contact[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const itemsPerPage = 20;

  // Form state
  const [isFormOpen, setIsFormOpen] = useState(false);
  const [formMode, setFormMode] = useState<FormMode>('create');
  const [editingContact, setEditingContact] = useState<Contact | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Delete state
  const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
  const [contactToDelete, setContactToDelete] = useState<Contact | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);

  // Get auth token for API calls
  const getAuthToken = useCallback(() => {
    return token || localStorage.getItem('helix_token') || sessionStorage.getItem('helix_token');
  }, [token]);

  // Fetch contacts from REAL API
  const fetchContacts = useCallback(async () => {
    console.log('Ì≥û fetchContacts called');
    
    const authToken = getAuthToken();
    if (!authToken || !user) {
      console.log('‚ùå No token/user, showing error');
      showError('Authentication required', 'Please log in to view contacts');
      return;
    }

    console.log('‚úÖ Starting fetch from REAL API...');
    setLoading(true);
    
    try {
      console.log('Ì¥ê Fetching contacts with auth token');
      const contactsData = await contactsService.getAll();
      console.log('‚úÖ Contacts loaded from API:', contactsData.length);
      
      setContacts(contactsData);
      setFilteredContacts(contactsData);
      
      if (contactsData.length === 0) {
        info('No contacts found', 'Create your first contact to get started');
      }

    } catch (err) {
      console.error('‚ùå Error in fetchContacts:', err);
      showError(
        'Failed to load contacts', 
        err instanceof Error ? err.message : 'Please check your connection and try again'
      );
    } finally {
      console.log('‚úÖ Setting loading to false');
      setLoading(false);
    }
  }, [getAuthToken, user, showError, info]);

  // Initial fetch - Only fetch once on mount
  useEffect(() => {
    console.log('Ì¥É Initial fetch on mount');
    fetchContacts();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Filter contacts based on search term
  useEffect(() => {
    if (!searchTerm.trim()) {
      setFilteredContacts(contacts);
    } else {
      const filtered = contacts.filter(contact =>
        `${contact.firstName} ${contact.lastName}`.toLowerCase().includes(searchTerm.toLowerCase()) ||
        contact.email.toLowerCase().includes(searchTerm.toLowerCase()) ||
        (contact.phone && contact.phone.toLowerCase().includes(searchTerm.toLowerCase()))
      );
      setFilteredContacts(filtered);
    }
    
    // Reset to page 1 when search changes
    setCurrentPage(1);
  }, [contacts, searchTerm]);

  // Calculate pagination
  useEffect(() => {
    const totalFiltered = filteredContacts.length;
    setTotalPages(Math.ceil(totalFiltered / itemsPerPage));
  }, [filteredContacts]);

  // Get current page contacts
  const getCurrentPageContacts = () => {
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    return filteredContacts.slice(startIndex, endIndex);
  };

  // Form Handlers
  const handleCreateContact = () => {
    setFormMode('create');
    setEditingContact(null);
    setIsFormOpen(true);
  };

  const handleEditContact = (contact: Contact) => {
    setFormMode('edit');
    setEditingContact(contact);
    setIsFormOpen(true);
  };

  const handleDeleteClick = (contact: Contact) => {
    setContactToDelete(contact);
    setIsDeleteModalOpen(true);
  };

  const handleDeleteConfirm = async () => {
    if (!contactToDelete) return;

    setIsDeleting(true);
    console.log('Ì∑ëÔ∏è Deleting contact:', contactToDelete.id);

    try {
      await contactsService.delete(contactToDelete.id);
      
      // Remove contact from state
      setContacts(prev => prev.filter(contact => contact.id !== contactToDelete.id));
      setFilteredContacts(prev => prev.filter(contact => contact.id !== contactToDelete.id));
      
      success(
        'Contact deleted', 
        `${contactToDelete.firstName} ${contactToDelete.lastName} has been removed from your contacts`
      );
      
      // Close modal and reset
      setIsDeleteModalOpen(false);
      setContactToDelete(null);
      
    } catch (err) {
      console.error('Delete error:', err);
      showError(
        'Failed to delete contact', 
        err instanceof Error ? err.message : 'Please try again'
      );
    } finally {
      setIsDeleting(false);
    }
  };

  const handleDeleteCancel = () => {
    setIsDeleteModalOpen(false);
    setContactToDelete(null);
  };

  const handleFormSubmit = async (formData: any) => {
    setIsSubmitting(true);
    console.log('Ì≥ù Form submission:', formData);

    try {
      if (formMode === 'create') {
        // Create new contact via API
        const newContact = await contactsService.create(formData);
        console.log('‚úÖ Contact created:', newContact);
        
        // Add to state
        setContacts(prev => [newContact, ...prev]);
        setFilteredContacts(prev => [newContact, ...prev]);
        
        success('Contact created', `${formData.firstName} ${formData.lastName} has been added to your contacts`);
      } else {
        // Update existing contact via API
        if (!editingContact) return;

        const updatedContact = await contactsService.update(editingContact.id, formData);
        console.log('‚úÖ Contact updated:', updatedContact);
        
        // Update in state
        setContacts(prev => 
          prev.map(contact => 
            contact.id === editingContact.id ? updatedContact : contact
          )
        );
        setFilteredContacts(prev =>
          prev.map(contact =>
            contact.id === editingContact.id ? updatedContact : contact
          )
        );
        
        success('Contact updated', `${formData.firstName} ${formData.lastName} has been updated`);
      }

      setIsFormOpen(false);
    } catch (err) {
      console.error('Form submission error:', err);
      showError(
        formMode === 'create' ? 'Failed to create contact' : 'Failed to update contact',
        err instanceof Error ? err.message : 'Please try again'
      );
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleFormCancel = () => {
    setIsFormOpen(false);
    setEditingContact(null);
  };

  const handleSearchChange = (e: ChangeEvent<HTMLInputElement>) => {
    setSearchTerm(e.target.value);
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  console.log('Ì≥ä ContactsPage render, loading:', loading, 'contacts:', contacts.length, 'filtered:', filteredContacts.length);

  if (loading && contacts.length === 0) {
    console.log('‚è≥ Rendering loading state');
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="flex items-center justify-between mb-6">
          <div>
            <h1 className="text-2xl font-bold text-gray-900">Contacts</h1>
            <p className="text-gray-600">Manage your organization's contacts</p>
          </div>
          <Button disabled>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            Loading...
          </Button>
        </div>
        <Card className="p-8">
          <div className="flex flex-col items-center justify-center space-y-4">
            <LoadingSpinner size="lg" />
            <p className="text-gray-600">Loading contacts...</p>
          </div>
        </Card>
      </div>
    );
  }

  console.log('Ì≥ã Rendering contacts table with', filteredContacts.length, 'contacts');
  return (
    <div className="container mx-auto px-4 py-8">
      {/* Contact Form Modal */}
      <Modal
        isOpen={isFormOpen}
        onClose={handleFormCancel}
        size="lg"
      >
        <ContactForm
          mode={formMode}
          contact={editingContact || undefined}
          onSubmit={handleFormSubmit}
          onCancel={handleFormCancel}
          isLoading={isSubmitting}
        />
      </Modal>

      {/* Delete Confirmation Modal */}
      <ConfirmationModal
        isOpen={isDeleteModalOpen}
        onClose={handleDeleteCancel}
        onConfirm={handleDeleteConfirm}
        title="Delete Contact"
        description={`Are you sure you want to delete "${contactToDelete?.firstName} ${contactToDelete?.lastName}"? This action cannot be undone.`}
        confirmText={isDeleting ? "Deleting..." : "Delete Contact"}
        cancelText="Cancel"
        variant="destructive"
        isLoading={isDeleting}
      />

      {/* Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 mb-6">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Contacts</h1>
          <p className="text-gray-600">
            {filteredContacts.length} contact{filteredContacts.length !== 1 ? 's' : ''} found
            {searchTerm && ` for "${searchTerm}"`}
          </p>
        </div>
        <Button onClick={handleCreateContact}>
          <Plus className="mr-2 h-4 w-4" />
          Add Contact
        </Button>
      </div>

      {/* Search Bar */}
      <Card className="mb-6">
        <div className="p-4">
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5" />
            <Input
              type="search"
              placeholder="Search contacts by name, email, or phone..."
              className="pl-10"
              value={searchTerm}
              onChange={handleSearchChange}
            />
          </div>
        </div>
      </Card>

      {/* Contacts Table */}
      <Card>
        {filteredContacts.length === 0 ? (
          <EmptyState
            title={searchTerm ? "No matching contacts" : "No contacts yet"}
            message={searchTerm ? "Try adjusting your search terms" : "Get started by adding your first contact"}
            actionLabel="Add Contact"
            onAction={handleCreateContact}
          />
        ) : (
          <>
            <div className="overflow-x-auto">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Name</TableHead>
                    <TableHead>Email</TableHead>
                    <TableHead>Phone</TableHead>
                    <TableHead>Created</TableHead>
                    <TableHead className="text-right">Actions</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {getCurrentPageContacts().map((contact) => (
                    <TableRow key={contact.id}>
                      <TableCell className="font-medium">
                        {contact.firstName} {contact.lastName}
                      </TableCell>
                      <TableCell>{contact.email}</TableCell>
                      <TableCell>{contact.phone || '‚Äî'}</TableCell>
                      <TableCell>{formatDate(contact.createdAt)}</TableCell>
                      <TableCell className="text-right space-x-2">
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={() => handleEditContact(contact)}
                        >
                          Edit
                        </Button>
                        <Button
                          variant="destructive"
                          size="sm"
                          onClick={() => handleDeleteClick(contact)}
                        >
                          Delete
                        </Button>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </div>

            {/* Pagination */}
            {totalPages > 1 && (
              <div className="flex items-center justify-between p-4 border-t">
                <div className="text-sm text-gray-700">
                  Showing {(currentPage - 1) * itemsPerPage + 1} to {Math.min(currentPage * itemsPerPage, filteredContacts.length)} of {filteredContacts.length} contacts
                </div>
                <div className="flex space-x-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
                    disabled={currentPage === 1}
                  >
                    Previous
                  </Button>
                  <div className="flex items-center px-3 text-sm text-gray-600">
                    Page {currentPage} of {totalPages}
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}
                    disabled={currentPage === totalPages}
                  >
                    Next
                  </Button>
                </div>
              </div>
            )}
          </>
        )}
      </Card>
    </div>
  );
};
